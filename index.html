<html>
<head>
	<title>Smartphone Controller Game</title>
	<script src="/socket.io/socket.io.js"></script>
	<script src="//davidshimjs.github.com/qrcodejs/qrcode.min.js"></script>
	<script src="//threejs.org/build/three.min.js"></script>
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/jquerykeyframes/0.0.9/jquery.keyframes.min.js"></script>
	<script src="/public/velocity.js"></script>
	<style>
		body{
			margin: 0;
		}
		#QR_code{
			position: absolute;
			top: 0;
			left: 0;
			padding: 20px;
			background: white;
			z-index:3;
		}
		#render_stick{
			position: absolute;
			top: 30%;
			left: 45%;
			z-index: 2;
		}

		.animated { 
    width:260px;
    height:640px;
    background-image:url('http://visualidentity.cachefly.net/studio/websocket/images/pinata_small.png'); 
    position:absolute;
    left: 40%;
    top: 10px;
    background-repeat: no-repeat;
}

         #donkeyContainer {
		    width:22px;
		    height:22px;
		    position: absolute;
		    left: 40%;
		    top: 0;
		}
         
         /*@-webkit-keyframes swing { 
            20%, 40%, 60%, 80%, 100% { -webkit-transform-origin: top center; } 
            20% { -webkit-transform: rotate(30deg); } 
            40% { -webkit-transform: rotate(-30deg); } 
            60% { -webkit-transform: rotate(20deg); } 
            80% { -webkit-transform: rotate(-20deg); } 
            100% { -webkit-transform: rotate(0deg); } 
         }
         
         @keyframes swing { 
            20% { transform: rotate(30deg); } 
            40% { transform: rotate(-30deg); } 
            60% { transform: rotate(20deg); } 
            80% { transform: rotate(-20deg); } 
            100% { transform: rotate(0deg); } 
         }
         
         .swing { 
            -webkit-transform-origin: top center; 
            transform-origin: top center; 
            -webkit-animation-name: swing; 
            animation-name: swing; 
         }*/
	</style>
</head>
<body>
	<div>Accel</div>
	<div id="accellx"></div>
	<div id="accelly"></div>
	<div id="accellz"></div><br/><br/>
	<div>AccelGrav</div>
	<div id="accellGravx"></div>
	<div id="accellGravy"></div>
	<div id="accellGravz"></div><br/><br/>
	<div>Rotation</div>
	<div id="rotationx"></div>
	<div id="rotationy"></div>
	<div id="rotationz"></div><br/><br/>
	<div id="collision-check">Hit Points: -</div>
</body>
<script>

var ip = '192.168.167.130', // Your ip
		port = ':2000',
		io = io.connect(),
		current_url = window.location.href;
		runswing = false;

 
            function swing(rotation) {
            		swingrotation = rotation;
            		swingtime = 1500;
            		swings = 5;
            		console.log(swingrotation);
            		$('#donkeyContainer').velocity({rotateZ: rotation}, {duration: swingtime});
                     if(swingrotation > 5){
                     swingrotation *= -1;
                    swingrotation = swingrotation/2;
                    swing(swingrotation);
                } else {
                	$('#pendulum-parent').velocity({rotateZ: 0}, {duration: swingtime});
                }
            }

io.on('connect', function() {


	// Game setup
	var game = function(ip){

		
		var QR_code_element,
		create_QR = function(){

			var QR_code,
					url = "http://" + ip + port + "?id=" + io.id;

			// Create the container for the QR code to be created in
			QR_code_element = document.createElement('div');

			QR_code_element.innerHTML = io.id;

			// Assign an id to the element
			QR_code_element.id = "QR_code";

			// Append QR code element to the body
			document.body.appendChild(QR_code_element);

			// Assign the actual DOM element
			QR_code_element = document.getElementById('QR_code');

			// Create a QRCode
			QR_code = new QRCode("QR_code");
			QR_code.makeCode(url);
		},
		
		game_connected = function(){

			create_QR();
			io.removeListener('game_connected', game_connected);
		},
		collision_check = function(div1, div2) {

			rect1Pos = div1.getBoundingClientRect();
			rect2Pos = div2.getBoundingClientRect();

			var rect1 = {x: (rect1Pos.left + (rect1Pos.right - rect1Pos.left)/4), y: rect1Pos.top, width: ((rect1Pos.right - rect1Pos.left)/2), height: (rect1Pos.bottom - rect1Pos.top)}
			var rect2 = {x: (rect2Pos.left + (rect2Pos.right - rect2Pos.left)/4), y: rect2Pos.top, width: ((rect2Pos.right - rect2Pos.left)/2), height: (rect2Pos.bottom - rect2Pos.top)}

			if (rect1.x < rect2.x + rect2.width &&
				rect1.x + rect1.width > rect2.x &&
				rect1.y < rect2.y + rect2.height &&
				rect1.height + rect1.y > rect2.y) {
				console.log('collision');
			} else {
				// console.log('not hit');
			}
	},

		hit_points = 0,
		render = function(){

			//Change colour on swing
			if(controller_state.swing){
				stick.style.backgroundColor = "green";
			}
			else{
				stick.style.backgroundColor = "transparent";
			}

			//If hit is detected, take away hit points
			if(collision_check(stick, donkey) && controller_state.swing){
				StickPos = stick.getBoundingClientRect();
				PinataPos = donkey.getBoundingClientRect();
				// alert("Stick: " + StickPos.top + " : " + StickPos.left + " || Pinata: " + PinataPos);
				//Convert both forces to positive
				if(controller_state.steerx < 0){controller_state.steerx = controller_state.steerx * -1;}
				if(controller_state.steerz < 0){controller_state.steerz = controller_state.steerz * -1;}

				//Check which force has higher value
				highest_force = controller_state.steerz;
				if(controller_state.steerx > controller_state.steerz){
					highest_force = controller_state.steerx;
				}
				console.log(-(controller_state.velocityy));
				swing(50);
				//Use highest force as multiplier
				hit_points = hit_points - (100 * highest_force);
				collision.innerHTML = 'Hit Points: ' + parseInt(hit_points);
			}

			/*** MOVEMENT ***/
			//Get current accelerometer reading
			stick_xpos = -(controller_state.steerz * (window.innerWidth * 4));
			stick_ypos = -(controller_state.steerx * (window.innerHeight));

			//Non-median based movement
			//if(controller_state.swing){
			//	stick.style.transform = 'translateX(' + (stick_xpos / 3) + 'px) rotate(' + (stick_xpos / 6) + 'deg)';
			//}
			//else{
			//	stick.style.transform = 'translateX(' + stick_xpos + 'px) translateY(' + stick_ypos + 'px) rotate(' + (stick_xpos / 6) + 'deg)';
			//}

			//Use median of accelerometer readings to calculate movement
			if(prevx.length > 6 && prevy.length > 6){
				
				//Get median for x readings
				xlow = 0;
				xhigh = 0;
				for(var key in prevx){
				    if(prevx[key] > xhigh){ xhigh = prevx[key]; }
				    if(prevx[key] < xlow){ xlow = prevx[key]; } 
				}
				xmedian = (xhigh + xlow) / 2;

				//Get median for y readings
				ylow = 0;
				yhigh = 0;
				for(var key in prevy){
				    if(prevy[key] > yhigh){ yhigh = prevy[key]; }
				    if(prevy[key] < ylow){ ylow = prevy[key]; } 
				}
				ymedian = (yhigh + ylow) / 2;

				//Move stick according to controller orientation
				if(controller_state.orientation == 'left'){
					stick.style.transform = 'translateX(' + -(xmedian * 2) + 'px) translateY(' + -(ymedian) + 'px) rotate(' + -(xmedian / 6) + 'deg)';
				}
				else{
					stick.style.transform = 'translateX(' + (xmedian * 2) + 'px) translateY(' + ymedian + 'px) rotate(' + (xmedian / 6) + 'deg)';
				}
				
			}			

			//Update array of accelerometer readings (as long as not in swing mode)
			if(!controller_state.swing){
				if(prevx.length <= 7){
					prevx.push(stick_xpos);
				}
				else{
					prevx.shift();
					prevx.push(stick_xpos);
				}


				if(prevx.length <= 7){
					prevy.push(stick_ypos);
				}
				else{
					prevy.shift();
					prevy.push(stick_ypos);
				}
			}
		
			/*
			accelerate: false,
			steerx: 0,
			steery: 0,
			steerz: 0,
			swing: false
			*/
			requestAnimationFrame(render);
		},


		controller_state = {};


		stick = document.createElement("div");
		stick.id = 'render_stick';
		stick.innerHTML = '<img src="http://visualidentity.cachefly.net/studio/websocket/images/Big_Stick.png">';
		document.body.appendChild(stick);

		var donkeyContainer = document.createElement("div");
		donkeyContainer.id = 'donkeyContainer';
		document.body.appendChild(donkeyContainer);

		donkey = document.createElement("div");
		donkey.className = 'animated swing';
		// donkey.innerHTML = '<img src="http://visualidentity.cachefly.net/studio/websocket/images/pinata.png">';
		donkeyContainer.appendChild(donkey);

		collision = document.getElementById("collision-check");

		prevxfiller = document.getElementById("accellGravx");
		prevyfiller = document.getElementById("accellGravy");

		prevx = [];
		prevy = [];

		// This sets off the render loop
		render();

		// Tell the server that the client is connecting as a game
		io.emit('game_connect');

		// When the server has registered this client as a game
		// Create a QR code which will be a url with this game id as a parameter
		io.on('game_connected', game_connected);

		// When a controller has connected/disconnected to this game
		io.on('controller_connected', function(connected){

			if(connected){

				// Hide the QR code
				QR_code_element.style.display = "none";

				//Show stick
				// stick.style.display = 'block';

				//Add hit points for pinata
				hit_points = 2000;

			}else{

				// Show the QR code
				QR_code_element.style.display = "block";

				//Hide stick
				//stick.style.display = 'none';

				//Reset hit points
				hit_points = 0;

				//Reset controller state
				controller_state = {};

			}

		})

		// When the server sends a changed controller state update it in the game
		io.on('controller_state_change', function(state){

			controller_state = state;

		});

	},

	// Controller set up
	controller = function(game_id){

		// Tell the server this client is connecting as a controller
		// sending the id of the game to connect to
		io.emit('controller_connect', game_id);

		// Server will send back a connected boolean
		io.on('controller_connected', function(connected){

			if(connected){

				// Successful connection
				alert("Connected!");

				calibrate_button_left = document.createElement("input");
				calibrate_button_left.type = 'button';
				calibrate_button_left.id = 'calibrate_button_left';
				calibrate_button_left.value = 'Left';
				calibrate_button_left.style.width = '100%';
				calibrate_button_left.style.height = '200px';
				calibrate_button_left.style.background = 'green';
				calibrate_button_left.style.color = 'white';
				calibrate_button_left.style.fontSize = '3em';
				calibrate_button_left.onclick = function(){ set_controller_orientation('left'); };
				document.body.appendChild(calibrate_button_left);

				calibrate_button_right = document.createElement("input");
				calibrate_button_right.type = 'button';
				calibrate_button_right.id = 'calibrate_button_right';
				calibrate_button_right.value = 'Right';
				calibrate_button_right.style.width = '100%';
				calibrate_button_right.style.height = '200px';
				calibrate_button_right.style.background = 'green';
				calibrate_button_right.style.color = 'white';
				calibrate_button_right.style.fontSize = '3em';
				calibrate_button_right.onclick = function(){ set_controller_orientation('right'); };
				document.body.appendChild(calibrate_button_right);

				var controller_state = {
					steerx: 0,
					steery: 0,
					steerz: 0,
					swing: false,
					velocityy: 0,
					orientation: 'right'
				},
				emit_updates = function(){
					io.emit('controller_state_change', controller_state);
				}
				/*
				touchstart = function(e){
					//e.preventDefault();

					//controller_state.accelerate = true;
					//emit_updates();
				},
				touchend = function(e){
					//e.preventDefault();
					
					//controller_state.accelerate = false;
					//emit_updates();
				},
				*/
				devicemotion = function(e){
                    controller_state.steerx = e.accelerationIncludingGravity.x / 100;
                    controller_state.steery = e.accelerationIncludingGravity.y / 100;
                    controller_state.steerz = e.accelerationIncludingGravity.z / 100;
                    controller_state.velocityy = Math.round(e.acceleration.y);

                    /*
                    controllerx = Math.round(e.acceleration.x * 100);
                    controllery = Math.round(e.acceleration.y * 100);
                    controllerz = Math.round(e.acceleration.z * 100);
                    document.getElementById("accellx").innerHTML = "X-acceleration: " + controllerx;
                    document.getElementById("accelly").innerHTML = "Y-acceleration: " + controllery;
                    document.getElementById("accellz").innerHTML = "Z-acceleration: " + controllerz;

                    controllerIncludingGravityx = Math.round(e.accelerationIncludingGravity.x);
                    controllerIncludingGravityy = Math.round(e.accelerationIncludingGravity.y);
                    controllerIncludingGravityz = Math.round(e.accelerationIncludingGravity.z);
                    document.getElementById("accellGravx").innerHTML = "X-accelerationIncludingGravity: " + controllerIncludingGravityx;
                    document.getElementById("accellGravy").innerHTML = "Y-accelerationIncludingGravity: " + controllerIncludingGravityy;
                    document.getElementById("accellGravz").innerHTML = "Z-accelerationIncludingGravity: " + controllerIncludingGravityz;
					*/

                    emit_updates();
                },
                /*
                devicerotation = function(e){
                	rotationx = Math.round(e.alpha);
                    rotationy = Math.round(e.beta);
                    rotationz = Math.round(e.gamma);
                    document.getElementById("rotationx").innerHTML = "X-rotation: " + rotationx;
                    document.getElementById("rotationy").innerHTML = "Y-rotation: " + rotationy;
                    document.getElementById("rotationz").innerHTML = "Z-rotation: " + rotationz;

                    emit_updates();
                }
				*/
                detect_swing = function(e){
                	if(e.accelerationIncludingGravity.x > 13 || e.accelerationIncludingGravity.x  < -13 ){ //&&
                		//(e.accelerationIncludingGravity.z > 15 || e.accelerationIncludingGravity.z < -15 )){
                		controller_state.swing = true;
                	}
                	else{
                		controller_state.swing = false;
                	}

                	emit_updates();
                },
                set_controller_orientation = function(ori_string){
                	if(controller_state.orientation != ori_string){
	                	controller_state.orientation = ori_string;
	                	alert('Controller orientation set to ' + ori_string);
	                	emit_updates();
	                }
                }

				//document.body.addEventListener('touchstart', touchstart, false); // iOS & Android
				//document.body.addEventListener('MSPointerDown', touchstart, false); // Windows Phone
				//document.body.addEventListener('touchend', touchend, false); // iOS & Android
				//document.body.addEventListener('MSPointerUp', touchend, false); // Windows Phone
				window.addEventListener('devicemotion', devicemotion, false);
				window.addEventListener('devicemotion', detect_swing, false);
				//window.addEventListener('deviceorientation', devicerotation, false);

			}else{

				// Failed connection
				alert("Not connected!");
			}
		});

	}

	// If the url has an id in it
	if(current_url.indexOf('?id=') > 0){

		// Set up the controller using the game id in the url
		controller(current_url.split('?id=')[1])

	}else{

		// Set up the game using ip
		game(ip);

	}
});

</script>
</html>
